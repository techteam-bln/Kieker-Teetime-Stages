[increases overhead (first is slower)]
-for loop with list vs. array (reason: due to new instantiation of iterator)
-for loop with super type vs. concrete type (reason: due to less JIT optimization possibilities)
-passing by argument vs. instance variable (reason: unknown)
-pipe with array vs. single element (reason: unknown)
-access via array wrapper vs. array directly
-

[irrelevant w.r.t. overhead]
-foreach vs. index-based iteration
-iterative vs. recursive execution
-null-check vs. NullObject
-AbstractPipe vs. IPipe
-


[analysis performance results (50%)]

2:	7400 ns
8:	1200 ns (iterative; argument/return w/o pipe)
9:	9400 ns (executeWithPorts: queued pipe)
10:	4900 ns (executeWithPorts: single element pipe)
	10:	5400 ns (executeWithPorts: single element pipe; with setReschedulable() after each read)
11: 7400 ns (executeWithPorts: fixed sized pipe)
	11: 8600 ns (executeWithPorts: fixed sized pipe; with CircularArray(int))
	11: 8200 ns (executeWithPorts: fixed sized pipe; with CircularArray(int) w/o mask)
	11: 7800 ns (executeWithPorts: fixed sized pipe; with setReschedulable() after each read)
	11: 8200 ns (executeWithPorts: fixed sized pipe; with setReschedulable() after each read; non-final elements)
	11: 7800 ns (executeWithPorts: fixed sized pipe; with setReschedulable() after each read; non-final elements; pipeline searches for firstStageIndex)
12: 3300 ns (recursive; argument/return w/o pipe)
13: 3300 ns (recursive; argument/return w/o pipe; w/o pipeline class)
14: 21,000 ns (spsc pipe)
16: 14,500 ns (with distributor thread)
17: 8600 ns (as 16, but with direct feeding of SpScPipe)
